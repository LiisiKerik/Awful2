````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
Data Bool = Algebraic {False, True}
Class Applicative{f :: Star -> Star}<Functor[[Star, Star]]>(
  ap[t :: Star, u :: Star] :: f (t -> u) -> f t -> f u, return[t :: Star] :: t -> f t)
Class Bifunctor[[k, l, m]]<<Cat k, Cat l, Cat m>>{f :: k -> l -> m}(
  bimap[t :: k, u :: k, v :: l, w :: l] :: (t -> u) -> (v -> w) -> f t v -> f u w)
Class Container{f :: Star -> Star}(
  empty[t :: Star] :: f t,
  filter[t :: Star] :: (t -> Bool) -> f t -> f t,
  size[t :: Star] :: f t -> Int)
Class Field{t :: Star}<Ring>(inverse :: t -> Maybe t)
Class Finite{t :: Star}<Ord>(list :: List t)
Class Functor[[k, l]]<<Cat k, Cat l>>{f :: k -> l}(fmap[t :: k, u :: k] :: (t -> u) -> f t -> f u)
Class Monad{f :: Star -> Star}<Applicative>(bind[t :: Star, u :: Star] :: f t -> (t -> f u) -> f u)
Operator * multiply 7 Left
Operator + add 6 Left
Operator ++ concat 5 Right
Operator - minus 6 Left
Operator . compose 9 Right
Operator : Construct_List 5 Right
Operator <$> fmap 4 Left
Operator <*> ap 4 Left
Operator >>= bind 1 Left
Instance Applicative{Either _}(x <*> y = Match x {Left z -> Left z, Right f -> f <$> y}, return = Right)
Instance Applicative{Arrow{{Star}} _}((f <*> g) x = f x (g x), return x _ = x)
Instance Applicative{List}(
  x <*> y = Match x {EmptyList -> List, f : z -> (f <$> y) ++ (z <*> y)},
  return x = List (x))
Instance Applicative{Maybe}(x <*> y = Match x {Nothing -> Nothing, Just f -> f . y}, return = Just)
Instance Bifunctor[[Star, Star, Star]]{Either}(bimap f g x = Match x {Left y -> Left (f y), Right y -> Right (g y)})
Instance Bifunctor[[Star, Star, Star]]{Pair}(bimap f g (Mk_Pair x y) = Mk_Pair (f x) (g y))
Def Brackets[T :: Star]<Writeable T>(x :: T) :: List Char =
  Let Mk_Pair y z = Write_Brackets x In Match z {False -> y, True -> Lift "(" ++ y ++ Lift ")"}
Def Concat[T :: Star](x :: List T, y :: List T) :: List T = Match x {EmptyList -> y, z : a -> z : a ++ y}
Instance Container{List}(
  empty = List,
  filter f x = Match x {EmptyList -> List, y : z -> Let a = Filter f z In Match f y {False -> a, True -> y : a}},
  size x = Match x {EmptyList -> 0, _ : y -> 1 + size y})
Instance Container{Maybe}(
  empty = Nothing,
  filter f x = bind x (y -> Match f y {False -> Nothing, True -> x}),
  size x = Match x {Nothing -> 0, _ -> 1})
Def Convert'[f :: Star -> Star, t :: Star]<Applicative f, Ring t>(x :: Int) :: f t = Lift (Convert x)
Def equal[t :: Star]<Ord t>(x :: t, y :: t) :: Bool = Match Compare x y {EQ -> True, _ -> False}
Instance Field{Bool}(inverse x = Match x {False -> Nothing, True -> Just True})
Instance Field{Int}(inverse x = Match x {-1 -> Just -1, 1 -> Just 1, Default -> Nothing})
Instance Field{Pair T U}<Field T, Field U>(inverse (Mk_Pair x y) = Mk_Pair <$> Inverse x <*> Inverse y)
Instance Finite{Bool}(list = List (False, True))
Instance Finite{Comparison}(list = List (LT,  EQ,  GT))
Instance Finite{Either T U}<Finite T, Finite U>(list = Left . list ++ Right . list)
Instance Finite{Maybe T}<Finite T>(list = Nothing : Just <$> list)
Instance Finite{Pair T U}<Finite T, Finite U>(list = Zip Mk_Pair list list)
Def flatten[F :: Star -> Star, T :: Star]<Monad F>(x :: F (F T)) :: F T = bind x id
Instance[[k]]<<Cat k>> Functor[[k, Star]]{Arrow{{k}} _}(fmap = compose)
Instance Functor[[Star, Star]]{Either _}(fmap = right)
Instance Functor[[Star, Star]]{List}(fmap f x = Match x {EmptyList -> List, y : z -> f y : f <$> z})
Instance Functor[[Star, Star]]{Maybe}(
  fmap f x = Match x {Nothing -> Nothing, Just y -> Just (f y)})
Instance Functor[[Star, Star]]{Pair _}(fmap = right)
Def Greater[T :: Star]<Ord T>(x :: T, y :: T) :: Bool = Match Compare x y {GT -> True, Default -> False}
Def Greater_or_equal[T :: Star]<Ord T>(x :: T, y :: T) :: Bool = Match Compare x y {LT -> False, Default -> True}
Def Interleave[t :: Star](x :: List t, y :: List (List t)) :: List t =
  Match y {EmptyList -> List, z : a -> Concat z (Flatten (Concat x . a))}
Def Less[T :: Star]<Ord T>(x :: T, y :: T) :: Bool = Match Compare x y {LT -> True, Default -> False}
Def Less_or_equal[T :: Star]<Ord T>(x :: T, y :: T) :: Bool = Match Compare x y {GT -> False, Default -> True}
Def Max[T :: Star]<Ord T>(x :: T, y :: T) :: T = Match Compare x y {LT -> y, Default -> x}
Def Min[T :: Star]<Ord T>(x :: T, y :: T) :: T = Match Compare x y {LT -> x, Default -> y}
Def Minus[T :: Star]<Ring T>(x :: T, y :: T) :: T = x + Negate y
Instance Monad{Either _}(bind x f = Match x {Left y -> Left y, Right y -> f y})
Instance Monad{Arrow{{Star}} _}(bind f g x = g (f x) x)
Instance Monad{List}(bind x f = Match x {EmptyList -> List, y : z -> Concat (f y) (z >>= f)})
Instance Monad{Maybe}(bind x f = Match x {Nothing -> Nothing, Just y -> f y})
Def Multiply'[F :: Star -> Star, T :: Star]<Applicative F, Ring T> :: F T -> F T -> F T = Zip Multiply
Def Negate'[F :: Star -> Star, T :: Star]<Functor[[Star, Star]] F, Ring T> :: F T -> F T = fmap Negate
Instance Ord{Bool}(
  Compare x y = Match x {False -> Match y {False -> EQ, True -> LT}, True -> Match y {False -> GT, True -> EQ}})
Instance Ord{Comparison}(
  Compare x y =
    Match x {
      LT -> Match y {LT -> EQ, Default -> LT},
      EQ -> Match y {LT -> GT, EQ -> EQ, GT -> LT},
      GT -> Match y {GT -> EQ, Default -> GT}})
Instance Ord{Either T U}<Ord T, Ord U>(
  Compare x y =
    Match x {
      Left z -> Match y {Left w -> Compare z w, Right _ -> LT},
      Right z -> Match y {Left _ -> GT, Right w -> Compare z w}})
Instance Ord{List T}<Ord T>(
  Compare x y =
    Match x {
      EmptyList -> Match y {EmptyList -> EQ, _ -> LT},
      z : a -> Match y {Empty_List -> GT, b : c -> Compare (Mk_Pair z a) (Mk_Pair b c)}})
Instance Ord{Maybe T}<Ord T>(
  Compare x y =
    Match x {Nothing -> Match y {Nothing -> EQ, Just _ -> LT}, Just z -> Match y {Nothing -> GT, Just w -> Compare z w}})
Instance Ord{Pair T U}<Ord T, Ord U>(
  Compare (Mk_Pair x y) (Mk_Pair z a) = Match Compare x z {LT -> LT, EQ -> Compare y a, GT -> GT})
Instance Ring{t * u}<Ring t, Ring u>(
  Mk_Pair x y + Mk_Pair z a = Mk_Pair (x + z) (y + a),
  convert x = Mk_Pair (convert x) (convert x),
  Mk_Pair x y * Mk_Pair z a = Mk_Pair (x * z) (y * a),
  negate (Mk_Pair x y) = Mk_Pair (negate x) (negate y))
Instance Ring{Bool}(add = notEqual, convert x = equal (unwrap (div x 2)) 1, multiply = min, negate = id)
Def Unwrap[T :: Star](x :: Maybe T) :: T = Match x {Nothing -> Crash, Just y -> y}
Def Write[T :: Star]<Writeable T>(x :: T) :: List Char = First (Write_Brackets x)
Def Write'(x :: List Char, y :: List (List Char)) :: List Char = Interleave (Lift " ") (x : y)
Instance Writeable{Char}(
  Write_Brackets c =
    Mk_Pair (Match c {Newline -> List ("N", "e", "w", "l", "i", "n", "e"), Default -> List (""", c, """)}) False)
Instance Writeable{Comparison}(
  Write_Brackets x = Mk_Pair (Match x {LT -> List ("L", "T"), EQ -> List ("E", "Q"), GT -> List ("G", "T")}) False)
Instance Writeable{Either T U}<Writeable T, Writeable U>(
  Write_Brackets x =
    Mk_Pair
      (Match x {
        Left y -> Concat (List ("L", "e", "f", "t")) (Brackets y),
        Right y -> Concat (List ("R", "i", "g", "h", "t")) (Brackets y)})
      True)
Instance Writeable{List T}<Writeable T>(
  Write_Brackets x =
    Match x {
      EmptyList -> Mk_Pair (List ("L", "i", "s", "t")) 0,
      y : z ->
        Mk_Pair
          (Concat (List ("L", "i", "s", "t", " ", "(")) (Concat (Interleave (List (",", " ")) (Write . x)) (Lift ")")))
          1})
Instance Writeable{Bool}(
  Write_Brackets x = Mk_Pair (Match x {False -> List ("F", "a", "l", "s", "e"), True -> List ("T", "r", "u", "e")}) 0)
Instance Writeable{Maybe T}<Writeable T>(
  Write_Brackets x =
    Match x {
      Nothing -> Mk_Pair (List ("N", "o", "t", "h", "i", "n", "g")) False,
      Just y -> Mk_Pair (Concat (List ("W", "r", "a", "p", " ")) (Brackets y)) True})
Instance Writeable{Pair T U}<Writeable T, Writeable U>(
  Write_Brackets (Mk_Pair x y) = Mk_Pair (Write' (List ("P", "a", "i", "r")) (List (Brackets x, Brackets y))) True)
Def Zr[T :: Star]<Ring T> :: T = Convert 0
Def add'[f :: Star -> Star, t :: Star]<Applicative f, Ring t>(x :: f t, y :: f t) :: f t = add <$> x <*> y
Def identity[t :: Star]<Ring t> :: t = convert 1
Def isZr[t :: Star]<Ord t, Ring t> :: t -> Bool = Equal Zr
Def left[t :: Star, u :: Star, f :: Star -> Star -> Star, v :: Star]<Bifunctor f>(g :: t -> u) :: f t v -> f u v = bimap g id
Def not(x :: Bool) :: Bool = Match x {False -> True, True -> False}
Def notEqual[T :: Star]<Ord T>(x :: T, y :: T) :: Bool = Match Compare x y {EQ -> False, Default -> True}
Def right[t :: Star, u :: Star, f :: Star -> Star -> Star, v :: Star]<Bifunctor f> :: (t -> u) -> f v t -> f v u = bimap id
````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````