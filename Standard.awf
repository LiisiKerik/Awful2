````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
Class Applicative{f :: Star -> Star}<Functor>(
  ap[t :: Star, u :: Star] :: f (t -> u) -> f t -> f u, Return[t :: Star] :: t -> f t)
Class Bifunctor[[k, l, m]]<<Cat k, Cat l, Cat m>>{f :: k -> l -> m}(
  bimap[t :: k, u :: k, v :: l, w :: l] :: (t -> u) -> (v -> w) -> f t v -> f u w)
Class Container{f :: Star -> Star}(empty[t :: Star] :: f t, filter[t :: star] :: (t -> Logical) -> f t -> f t)
Class Field{t :: Star}<Ring>(inverse :: t -> Maybe t)
Class Finite{t :: Star}<Ord>(all :: List t)
Class Functor[[k, l]]<<Cat k, Cat l>>{f :: k -> l}(fmap[t :: k, u :: k] :: (t -> u) -> f t -> f u)
Class Monad{f :: Star -> Star}<Applicative>(bind[t :: Star, u :: Star] :: f t -> (t -> f u) -> f u)
Operator * multiply 7 Left
Operator + add 6 Left
Operator ++ concat 5 Right
Operator - minus 6 Left
Operator . compose 9 Right
Operator : Construct_List 5 Right
Operator <$> fmap 4 Left
Operator <*> ap 4 Left
Operator >>= bind 1 Left
Def Add'[F :: Star -> Star, T :: Star]<Applicative F, Ring T> :: F T -> F T -> F T = Zip Add
Instance Applicative{Either _}(x <*> y = Match x {Left z -> Left z, Right f -> f . y}, Return = Right)
Instance Applicative{Function _}((f <*> g) x = f x (g x), Return x _ = x)
Instance Applicative{List}(
  x <*> y = Match x {Empty_List -> List, Construct_List f z -> (f <$> y) ++ (z <*> y)},
  Return x = List (x))
Instance Applicative{Maybe}(x <*> y = Match x {Nothing -> Nothing, Wrap f -> f . y}, Lift = Wrap)
Instance Bifunctor[[Star, Star, Star]]{Either}(Bimap f g x = Match x {Left y -> Left (f y), Right y -> Right (g y)})
Instance Bifunctor[[Star, Star, Star]]{Pair}(Bimap f g (Mk_Pair x y) = Mk_Pair (f x) (g y))
Def Brackets[T :: Star]<Writeable T>(x :: T) :: List Char =
  Let Mk_Pair y z = Write_Brackets x In Match z {False -> y, True -> Lift "(" ++ y ++ Lift ")"}
Def Concat[T :: Star](x :: List T, y :: List T) :: List T = Match x {Empty_List -> y, Construct_List z a -> z : a ++ y}
Instance Container{List}(
  Empty = List,
  Filter f x =
    Match x {
      Empty_List -> List,
      Construct_List y z -> Let a = Filter f z In Match f y {False -> a, True -> Construct_List y a}})
Instance Container{Maybe}(Empty = Nothing, Filter f x = Bind x (y -> Match f y {False -> Nothing, True -> x}))
Def Convert'[f :: Star -> Star, T :: Star]<Applicative F, Ring T>(x :: Int) :: f T = Lift (Convert x)
Def Equal[T :: Star]<Ord T>(x :: T, y :: T) :: Logical = Match Compare x y {EQ -> True, _ -> False}
Instance Field{Int}(Inverse x = Match x {-1 -> Wrap -1, 1 -> Wrap 1, Default -> Nothing})
Instance Field{Logical}(Inverse x = Match x {False -> Nothing, True -> Wrap True})
Instance Field{Pair T U}<Field T, Field U>(Inverse (Mk_Pair x y) = Zip Mk_Pair (Inverse x) (Inverse y))
Instance Finite{Comparison}(All = List (LT,  EQ,  GT))
Instance Finite{Either T U}<Finite T, Finite U>(All = Left . All ++ Right . All)
Instance Finite{Logical}(All = List (False, True))
Instance Finite{Maybe T}<Finite T>(All = Construct_List Nothing (Wrap . All))
Instance Finite{Pair T U}<Finite T, Finite U>(All = Zip Mk_Pair All All)
Def Flatten[F :: Star -> Star, T :: Star]<Monad F>(x :: F (F T)) :: F T = Bind x Id
Instance[[K]]<<Cat K>> Functor[[K, Star]]{Arrow[[K]] _}(Fmap = Compose)
Instance Functor{Either _}(Fmap = Map_right)
Instance Functor{List}(Fmap f x = Match x {Empty_List -> List, Construct_List y z -> Construct_List (f y) (f . z)})
Instance Functor{Maybe}(Fmap f x = Match x {Nothing -> Nothing, Wrap y -> Wrap (f y)})
Instance Functor{Pair _}(Fmap = Map_right)
Def Greater[T :: Star]<Ord T>(x :: T, y :: T) :: Logical = Match Compare x y {GT -> True, Default -> False}
Def Greater_or_equal[T :: Star]<Ord T>(x :: T, y :: T) :: Logical = Match Compare x y {LT -> False, Default -> True}
Def Identity[T :: Star]<Ring T> :: T = Convert 1
Def Interleave[T :: Star](x :: List T, y :: List (List T)) :: List T =
  Match y {Empty_List -> List, z : a -> Concat z (Flatten (Concat x . a))}
Def Is_Zero[T :: Star]<Ord T, Ring T> :: T -> Logical = Equal Zr
Def Less[T :: Star]<Ord T>(x :: T, y :: T) :: Logical = Match Compare x y {LT -> True, Default -> False}
Def Less_or_equal[T :: Star]<Ord T>(x :: T, y :: T) :: Logical = Match Compare x y {GT -> False, Default -> True}
Def Map_left[T :: Star, U :: Star, F :: Star -> Star -> Star, V :: Star]<Bifunctor F>(f :: T -> U) :: F T V -> F U V = Bimap Id
Def Map_right[T :: Star, U :: Star, F :: Star -> Star -> Star, V :: Star]<Bifunctor F> :: (T -> U) -> F V T -> F V U = Bimap Id
Def Max[T :: Star]<Ord T>(x :: T, y :: T) :: T = Match Compare x y {LT -> y, Default -> x}
Def Min[T :: Star]<Ord T>(x :: T, y :: T) :: T = Match Compare x y {LT -> x, Default -> y}
Def Minus[T :: Star]<Ring T>(x :: T, y :: T) :: T = x + Negate y
Instance Monad{Either _}(Bind x f = Match x {Left y -> Left y, Right y -> f y})
Instance Monad{Function _}(Bind f g x = g (f x) x)
Instance Monad{List}(Bind x f = Match x {Empty_List -> List, y : z -> Concat (f y) (z >>= f)})
Instance Monad{Maybe}(Bind x f = Match x {Nothing -> Nothing, Wrap y -> f y})
Def Multiply'[F :: Star -> Star, T :: Star]<Applicative F, Ring T> :: F T -> F T -> F T = Zip Multiply
Def Negate'[F :: Star -> Star, T :: Star]<Functor F, Ring T> :: F T -> F T = Fmap Negate
Def Not(x :: Logical) :: Logical = Match x {False -> True, True -> False}
Def Not_equal[T :: Star]<Ord T>(x :: T, y :: T) :: Logical = Match Compare x y {EQ -> False, Default -> True}
Instance Ord{Comparison}(
  Compare x y =
    Match x {
      LT -> Match y {LT -> EQ, Default -> LT},
      EQ -> Match y {LT -> GT, EQ -> EQ, GT -> LT},
      GT -> Match y {GT -> EQ, Default -> GT}})
Instance Ord{Either T U}<Ord T, Ord U>(
  Compare x y =
    Match x {
      Left z -> Match y {Left w -> Compare z w, Right _ -> LT},
      Right z -> Match y {Left _ -> GT, Right w -> Compare z w}})
Instance Ord{List T}<Ord T>(
  Compare x y =
    Match x {
      Empty_List -> Match y {Empty_List -> EQ, Construct_List _ _ -> LT},
      Construct_List z a -> Match y {Empty_List -> GT, Construct_List b c -> Compare (Mk_Pair z a) (Mk_Pair b c)}})
Instance Ord{Logical}(
  Compare x y = Match x {False -> Match y {False -> EQ, True -> LT}, True -> Match y {False -> GT, True -> EQ}})
Instance Ord{Maybe T}<Ord T>(
  Compare x y =
    Match x {Nothing -> Match y {Nothing -> EQ, Wrap _ -> LT}, Wrap z -> Match y {Nothing -> GT, Wrap w -> Compare z w}})
Instance Ord{Pair T U}<Ord T, Ord U>(
  Compare (Mk_Pair x y) (Mk_Pair z a) = Match Compare x z {LT -> LT, EQ -> Compare y a, GT -> GT})
Instance Ring{Logical}(Add = Not_equal, Convert x = Equal (Unwrap (Div x 2)) 1, Multiply = Min, Negate = Id)
Instance Ring{Pair T U}<Ring T, Ring U>(
  Add (Mk_Pair x y) (Mk_Pair z a) = Mk_Pair (x + z) (y + a),
  Convert x = Mk_Pair (Convert x) (Convert x),
  Multiply (Mk_Pair x y) (Mk_Pair z a) = Mk_Pair (x * z) (y * a),
  Negate (Mk_Pair x y) = Mk_Pair (Negate x) (Negate y))
Def Unwrap[T :: Star](x :: Maybe T) :: T = Match x {Nothing -> Crash, Wrap y -> y}
Def Write[T :: Star]<Writeable T>(x :: T) :: List Char = First (Write_Brackets x)
Def Write'(x :: List Char, y :: List (List Char)) :: List Char = Interleave (Lift " ") (Construct_List x y)
Instance Writeable{Char}(
  Write_Brackets c =
    Mk_Pair (Match c {Newline -> List ("N", "e", "w", "l", "i", "n", "e"), Default -> List (""", c, """)}) False)
Instance Writeable{Comparison}(
  Write_Brackets x = Mk_Pair (Match x {LT -> List ("L", "T"), EQ -> List ("E", "Q"), GT -> List ("G", "T")}) False)
Instance Writeable{Either T U}<Writeable T, Writeable U>(
  Write_Brackets x =
    Mk_Pair
      (Match x {
        Left y -> Concat (List ("L", "e", "f", "t")) (Brackets y),
        Right y -> Concat (List ("R", "i", "g", "h", "t")) (Brackets y)})
      True)
Instance Writeable{List T}<Writeable T>(
  Write_Brackets x =
    Match x {
      Empty_List -> Mk_Pair (List ("L", "i", "s", "t")) False,
      Construct_List y z ->
        Mk_Pair
          (Concat (List ("L", "i", "s", "t", " ", "(")) (Concat (Interleave (List (",", " ")) (Write . x)) (Lift ")")))
          True})
Instance Writeable{Logical}(
  Write_Brackets x = Mk_Pair (Match x {False -> List ("F", "a", "l", "s", "e"), True -> List ("T", "r", "u", "e")}) False)
Instance Writeable{Maybe T}<Writeable T>(
  Write_Brackets x =
    Match x {
      Nothing -> Mk_Pair (List ("N", "o", "t", "h", "i", "n", "g")) False,
      Wrap y -> Mk_Pair (Concat (List ("W", "r", "a", "p", " ")) (Brackets y)) True})
Instance Writeable{Pair T U}<Writeable T, Writeable U>(
  Write_Brackets (Mk_Pair x y) = Mk_Pair (Write' (List ("P", "a", "i", "r")) (List (Brackets x, Brackets y))) True)
Def Zr[T :: Star]<Ring T> :: T = Convert 0
Def zipWith[F :: Star -> Star, T :: Star, U :: Star, V :: Star]<Applicative F>(f :: T -> U -> V, x :: F T) :: F U -> F V =
  Apply (f . x)
````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````